<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<meta name="author" content="Kris Jusiak">
<link rel="canonical" href="http://boost-experimental.github.io/di/extensions/index.html">
<title>Extensions - [Boost].DI</title>

<link href="../css/boostbook.css" rel="stylesheet">
<link href="../css/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div width="100%">
<a href="http://www.boost.org/"><img alt="Boost C++ Libraries" width="277" height="86" src="../images/boost.png"></a>
</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../examples/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../FAQ/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="#constructor-bindings">Constructor Bindings</a></span></dt>
    

    
        <dt><span class="section"><a href="#contextual-bindings">Contextual Bindings</a></span></dt>
    

    
        <dt><span class="section"><a href="#assisted-injection">Assisted Injection</a></span></dt>
    

    
        <dt><span class="section"><a href="#extensible-injector">Extensible Injector</a></span></dt>
    

    
        <dt><span class="section"><a href="#concepts">Concepts</a></span></dt>
    

    
        <dt><span class="section"><a href="#factory">Factory</a></span></dt>
    

    
        <dt><span class="section"><a href="#shared-factory">Shared Factory</a></span></dt>
    

    
        <dt><span class="section"><a href="#lazy">Lazy</a></span></dt>
    

    
        <dt><span class="section"><a href="#named-parameters">Named Parameters</a></span></dt>
    

    
        <dt><span class="section"><a href="#xml-injection">XML Injection</a></span></dt>
    

    
        <dt><span class="section"><a href="#serialize">Serialize</a></span></dt>
    

    
        <dt><span class="section"><a href="#types-dumper">Types Dumper</a></span></dt>
    

    
        <dt><span class="section"><a href="#uml-dumper">UML Dumper</a></span></dt>
    

    
        <dt><span class="section"><a href="#heap-provider">Heap Provider</a></span></dt>
    

    
        <dt><span class="section"><a href="#mocks-provider">Mocks Provider</a></span></dt>
    

    
        <dt><span class="section"><a href="#runtime-provider">Runtime Provider</a></span></dt>
    

    
        <dt><span class="section"><a href="#scoped-scope">Scoped Scope</a></span></dt>
    

    
        <dt><span class="section"><a href="#session-scope">Session Scope</a></span></dt>
    

    
        <dt><span class="section"><a href="#shared-scope">Shared Scope</a></span></dt>
    

</dl>
</div>



<div class="section">
<ul>
<li><a href="#constructor-bindings">Constructor Bindings</a></li>
<li><a href="#contextual-bindings">Contextual Bindings</a></li>
<li><a href="#assisted-injection">Assisted Injection</a></li>
<li><a href="#extensible-injector">Extensible Injector</a></li>
<li><a href="#concepts">Concepts</a></li>
<li><a href="#factory">Factory</a></li>
<li><a href="#shared-factory">Shared Factory</a></li>
<li><a href="#lazy">Lazy</a></li>
<li><a href="#named-parameters">Named Parameters</a></li>
<li><a href="#xml-injection">XML Injection</a></li>
<li><a href="#serialize">Serialize</a></li>
<li><a href="#types-dumper">Types Dumper</a></li>
<li><a href="#uml-dumper">UML Dumper</a></li>
<li><a href="#heap-provider">Heap Provider</a></li>
<li><a href="#mocks-provider">Mocks Provider</a></li>
<li><a href="#runtime-provider">Runtime Provider</a></li>
<li><a href="#scoped-scope">Scoped Scope</a></li>
<li><a href="#session-scope">Session Scope</a></li>
<li><a href="#shared-scope">Shared Scope</a></li>
</ul>
<hr />
<h3 id="constructor-bindings">Constructor Bindings</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/bindings/constructor_bindings.hpp&quot;

#include &lt;cassert&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

namespace di = boost::di;


/*&lt;&lt;normal constructor - to_constructor binding is not needed for it&gt;&gt;*/
struct ctor {
  ctor(int i, std::string s, std::unique_ptr&lt;interface&gt; impl) {
    assert(i == 2);
    assert(s == &quot;hello&quot;);
    assert(dynamic_cast&lt;implementation*&gt;(impl.get()));
  }
};

/*&lt;&lt;ambiguous constructor&gt;&gt;*/
struct ambiguous_ctor {
  ambiguous_ctor(int i, std::string s) {
    assert(i == 2);
    assert(s == &quot;hello&quot;);
  }

  ambiguous_ctor(std::string s, int i) {
    assert(s == &quot;hello&quot;);
    assert(i == 2);
  }
};

/*&lt;&lt;variadic constructor - has to be `explicit`&gt;&gt;*/
struct variadic {
  template &lt;class... Ts&gt;
  explicit variadic(Ts&amp;&amp;... args) {  // has to be explicit
    assert(sizeof...(Ts) == 3);
    std::tuple&lt;Ts...&gt; ts{std::forward&lt;Ts&gt;(args)...};
    assert(std::get&lt;0&gt;(ts) == 2);
    assert(std::get&lt;1&gt;(ts) == &quot;hello&quot;);
    assert(dynamic_cast&lt;implementation*&gt;(std::get&lt;2&gt;(ts).get()));
  }
};

int main() {
  /*&lt;&lt;define constructor types&gt;&gt;*/
  auto injector = di::make_injector(
      di::bind&lt;ctor&gt;().to(di::extension::constructor&lt;int, std::string, std::unique_ptr&lt;interface&gt;&gt;())
    , di::bind&lt;ambiguous_ctor&gt;().to(di::extension::constructor&lt;int, std::string&gt;())
    , di::bind&lt;variadic&gt;().to(di::extension::constructor&lt;int, std::string, std::unique_ptr&lt;interface&gt;&gt;())

    /*&lt;&lt;additional bindings&gt;&gt;*/
    , di::bind&lt;interface&gt;().to&lt;implementation&gt;()
    , di::bind&lt;int&gt;().to(2), di::bind&lt;std::string&gt;().to(&quot;hello&quot;)
  );

  /*&lt;&lt;create types using defined constructors&gt;&gt;*/
  injector.create&lt;ctor&gt;();
  injector.create&lt;ambiguous_ctor&gt;();
  injector.create&lt;variadic&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/constructor_bindings.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/constructor_bindings.cpp</a></li>
</ul>
<h3 id="contextual-bindings">Contextual Bindings</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/bindings/contextual_bindings.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;

struct more_data {
  int i;
};

struct data {
  int i;
  more_data md;
};

class example {
 public:
  example(data&amp; d, int i, float f) {
    assert(87 == d.i);
    assert(99 == d.md.i);
    assert(42 == i);
    assert(123.f == f);
  }
};

int main() {
  auto injector = di::make_injector&lt;di::extension::contextual_bindings&gt;(
      di::bind&lt;&gt;().to(123.f)
    , di::bind&lt;int&gt;().to([](const auto&amp; injector) {
        if (di::extension::context(injector) == &quot;example-&gt;data&quot;) return 87;
        if (di::extension::context(injector) == &quot;example-&gt;data-&gt;more_data&quot;) return 99;
        return 42;
      })
  );

  /*&lt;&lt;create `example`&gt;&gt;*/
  injector.create&lt;example&gt;();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/contextual_bindings.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/bindings/contextual_bindings.cpp</a></li>
</ul>
<h3 id="assisted-injection">Assisted Injection</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/injections/assisted_injection.hpp&quot;

#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

namespace di = boost::di;


int main() {
  /*&lt;&lt;assisted_injection declaration using std function&gt;&gt;*/
  using example_assisted_injection = std::function&lt;std::unique_ptr&lt;example&gt;(int, double, std::string)&gt;;

  auto injector = di::make_injector(
      di::bind&lt;int&gt;().to(87)
    , di::bind&lt;interface&gt;().to&lt;implementation&gt;()
      /*&lt;&lt;bind `example_assisted_injection` to assisted_injection creating `example`&gt;&gt;*/
    , di::bind&lt;example_assisted_injection&gt;().to(di::extension::assisted_injection&lt;example&gt;())
  );

  auto f = injector.create&lt;example_assisted_injection&gt;();
  f(42, 123.0, &quot;str&quot;);
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/assisted_injection.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/assisted_injection.cpp</a></li>
</ul>
<h3 id="extensible-injector">Extensible Injector</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/injections/extensible_injector.hpp&quot;

#include &lt;cassert&gt;
#include &lt;memory&gt;

namespace di = boost::di;

struct interface {
  virtual ~interface() noexcept = default;
  virtual int num() = 0;
};

struct any {
  virtual ~any() noexcept = default;
};

struct object : any {};

struct implementation1 : interface {
  int num() override { return 1; }
};

struct implementation2 : interface {
  int num() override { return 2; }
};

struct implementation3 : interface {
  int num() override { return 3; }
};

struct example {
  example(std::unique_ptr&lt;interface&gt; i, std::shared_ptr&lt;implementation3&gt; im3) : i_(std::move(i)), im3_(im3) {}

  std::shared_ptr&lt;interface&gt; i_;
  std::shared_ptr&lt;interface&gt; im3_;
};

int main() {
  //&lt;&lt;create instance object&gt;&gt;
  auto im3_orig = std::make_shared&lt;implementation3&gt;();

  //&lt;&lt;define injector&gt;&gt;
  auto orig_injector = di::make_injector(
      //&lt;&lt;bind interface to implementation1&gt;&gt;
      di::bind&lt;interface&gt;().to&lt;implementation1&gt;().in(di::unique)

      //&lt;&lt;bind any to object&gt;&gt;
    , di::bind&lt;any&gt;().to&lt;object&gt;()

      //&lt;&lt;overridden binding for any, object to object&gt;&gt;
    , di::bind&lt;any, object&gt;().to&lt;object&gt;()[di::override]

      //&lt;&lt;bind implementation3 to shared instance&gt;&gt;
    , di::bind&lt;implementation3&gt;().to(im3_orig)
  );

  {
    //&lt;&lt;define extended injector&gt;&gt;
    auto extended_injector = di::make_injector(
        //&lt;&lt;make extensible injector from original injector&gt;&gt;
        di::extension::make_extensible(orig_injector)

        //&lt;&lt;override bound interface to implementation2&gt;&gt;
      , di::bind&lt;interface&gt;().to&lt;implementation2&gt;().in(di::unique)[di::override]
    );

    //&lt;&lt;both injectors live together&gt;&gt;
    auto orig_example = orig_injector.create&lt;example&gt;();
    assert(1 == orig_example.i_-&gt;num());
    assert(3 == orig_example.im3_-&gt;num());

    auto extended_example = extended_injector.create&lt;example&gt;();
    assert(2 == extended_example.i_-&gt;num());
    assert(3 == extended_example.im3_-&gt;num());

    //&lt;&lt;both injectors share the same dependency&gt;&gt;
    assert(extended_example.im3_ == orig_example.im3_);
    assert(im3_orig == orig_example.im3_);

    //&lt;&lt;injector supports multiple bindings&gt;&gt;
    assert(orig_injector.create&lt;std::shared_ptr&lt;any&gt;&gt;() == orig_injector.create&lt;std::shared_ptr&lt;object&gt;&gt;());
  }
  //&lt;&lt;after death of extended dependency original dependency is still alive&gt;&gt;
  assert(im3_orig == orig_injector.create&lt;std::shared_ptr&lt;implementation3&gt;&gt;());

  {
    //&lt;&lt;make_extensible can be called with empty injector&gt;&gt;
    auto empty_injector = di::make_injector();
    auto empty_extended_injector = di::make_injector(di::extension::make_extensible(empty_injector));
    auto instance = empty_extended_injector.create&lt;implementation1&gt;();
    assert(1 == instance.num());
  }
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/extensible_injector.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/extensible_injector.cpp</a></li>
</ul>
<h3 id="concepts">Concepts</h3>
<pre><code class="cpp">
#include &quot;boost/di/extension/injections/concepts.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;

template &lt;typename T&gt;
concept bool Dummy() {
  return requires(T a) { {a.dummy()}; };
}

struct DummyImpl {
  void dummy() {}
};

auto dummy_concept = [] {};

struct example {
  BOOST_DI_INJECT(example, int i, auto t, (named = dummy_concept) Dummy d, (named = dummy_concept) std::unique_ptr&lt;Dummy&gt; up) {
    assert(42 == i);
    static_assert(std::is_same&lt;decltype(t), int&gt;::value, &quot;&quot;);
    assert(87 == t);
    static_assert(std::is_same&lt;decltype(d), DummyImpl&gt;::value, &quot;&quot;);
    static_assert(std::is_same&lt;decltype(up), std::unique_ptr&lt;DummyImpl&gt;&gt;::value, &quot;&quot;);
  }
};

int main() {
  auto injector = di::make_injector&lt;di::extension::concepts_provider_config&gt;(
      di::bind&lt;int&gt;.to(42)
    , di::bind&lt;di::_&gt;.to(87)
    , di::bind&lt;di::_&gt;().named(dummy_concept).to&lt;DummyImpl&gt;()
  );

  injector.create&lt;example&gt;();
}

</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/concepts.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/concepts.cpp</a></li>
</ul>
<h3 id="factory">Factory</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/injections/factory.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;

struct interface {
  virtual ~interface() noexcept = default;
  virtual void dummy1() = 0;
};

struct implementation : interface {
  void dummy1() override {}
};

struct implementation_exception : interface {
#if defined(__EXCEPTIONS)
  implementation_exception() { throw 0; }
#endif
  void dummy1() override {}
};

struct implementation_with_args : interface {
  implementation_with_args(int i, double d) {
    assert(42 == i);
    assert(87.0 == d);
  }
  void dummy1() override {}
};

struct implementation_with_injected_args : interface {
  implementation_with_injected_args(int i, double d) {
    assert(123 == i);
    assert(87.0 == d);
  }
  void dummy1() override {}
};

/*&lt;&lt;example `example` class&gt;&gt;*/
class example {
 public:
  example(const di::extension::ifactory&lt;interface&gt;&amp; f1, const di::extension::ifactory&lt;interface, int, double&gt;&amp; f2,
          const di::extension::ifactory&lt;interface, double&gt;&amp; f3) {
    assert(dynamic_cast&lt;implementation*&gt;(f1.create().get()));
    assert(dynamic_cast&lt;implementation_with_args*&gt;(f2.create(42, 87.0).get()));
    assert(dynamic_cast&lt;implementation_with_injected_args*&gt;(f3.create(87.0).get()));
  }
};

int main() {
  //&lt;&lt;define injector&gt;&gt;
  auto module = [] { return di::make_injector(di::bind&lt;&gt;().to(123)); };

  auto injector = di::make_injector(module()
  // &lt;&lt;bind instance just to make sure that factory doesn't affect injector&gt;&gt;
  , di::bind&lt;interface&gt;().to(std::make_shared&lt;implementation&gt;())

  // &lt;&lt;bind instance which throws exception to make sure that exception doesn't affect injector&gt;&gt;
  , di::bind&lt;di::extension::ifactory&lt;implementation_exception&gt;&gt;().to(di::extension::factory&lt;implementation_exception&gt;{})

  //&lt;&lt;bind factory interface to implementation&gt;&gt;
  , di::bind&lt;di::extension::ifactory&lt;interface&gt;&gt;().to(di::extension::factory&lt;implementation&gt;{})

  //&lt;&lt;bind factory interface with parameters to implementation_with_args&gt;&gt;
  , di::bind&lt;di::extension::ifactory&lt;interface, int, double&gt;&gt;().to(di::extension::factory&lt;implementation_with_args&gt;{})

  //&lt;&lt;bind factory interface with some parameters injected to implementation_with_injected_args&gt;&gt;
  , di::bind&lt;di::extension::ifactory&lt;interface, double&gt;&gt;().to(di::extension::factory&lt;implementation_with_injected_args&gt;{})
  );

  /*&lt;&lt;create `example`&gt;&gt;*/
  injector.create&lt;example&gt;();

/*&lt;&lt;create `implementation_exception`&gt;&gt;*/
#if defined(__EXCEPTIONS)
  auto exception_thrown = false;
  try {
    injector.create&lt;const implementation_exception&amp;&gt;();
  } catch (...) {
    exception_thrown = true;
  }
  assert(exception_thrown);
#endif

  // Check whether injector is affected by factory
  assert(injector.create&lt;std::shared_ptr&lt;interface&gt;&gt;());
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/factory.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/factory.cpp</a></li>
</ul>
<h3 id="shared-factory">Shared Factory</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/injections/shared_factory.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;
namespace ext = di::extension;

struct interface1 {
  virtual ~interface1() noexcept = default;
  virtual void dummy() = 0;
};

struct interface2 {
  virtual ~interface2() noexcept = default;
  virtual void dummy() = 0;
};

struct implementation : interface1, interface2 {
  static auto&amp; ctor_calls() {
    static auto calls = 0;
    return calls;
  }
  static auto&amp; dtor_calls() {
    static auto calls = 0;
    return calls;
  }
  implementation() { ctor_calls()++; }
  ~implementation() { dtor_calls()++; }
  void dummy() override {}
};

struct implementation_exception : interface1 {
#if defined(__EXCEPTIONS)
  implementation_exception() { throw 0; }
#endif
  void dummy() override {}
};

int main() {
  assert(!implementation::ctor_calls());
  assert(!implementation::dtor_calls());

  {
    //&lt;&lt;define injector&gt;&gt;
    auto injector = di::make_injector(
      di::bind&lt;implementation_exception&gt;().to(ext::shared_factory&lt;implementation_exception&gt;([&amp;](const auto&amp; inner_injector)
      {
        //&lt;&lt;throws an exception here&gt;&gt;
        return inner_injector.template create&lt;std::shared_ptr&lt;implementation_exception&gt;&gt;();
      })),
      //&lt;&lt;bind factory interface to implementation&gt;&gt;
      di::bind&lt;interface1, implementation&gt;().to(ext::shared_factory&lt;implementation, ext::no_recursion&gt;([&amp;](const auto&amp; inner_injector)
      {
        static int calls = 0;
        assert(1 == ++calls);
        //&lt;&lt;shouldn't be recursive call here&gt;&gt;
        return inner_injector.template create&lt;std::shared_ptr&lt;implementation&gt;&gt;();
      })),
      di::bind&lt;interface2&gt;().to(ext::conditional_shared_factory&lt;implementation&gt;([&amp;]()
      {
        static int calls = 0;
        assert(1 == ++calls);
        return true;
      }))
    );

    //&lt;&lt;create `implementation` via `shared_factory`&gt;&gt;
    auto i1 = injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;();
    auto i2 = injector.create&lt;std::shared_ptr&lt;implementation&gt;&gt;();
    assert(i1);
    assert(i1 == i2);
    assert(1 == implementation::ctor_calls());
    assert(!implementation::dtor_calls());

    //&lt;&lt;create `interface` via `conditional_shared_factory`&gt;&gt;
    auto i3 = injector.create&lt;std::shared_ptr&lt;interface2&gt;&gt;();

#if defined(__EXCEPTIONS)
    auto exception_thrown = false;
    try {
      injector.create&lt;std::shared_ptr&lt;implementation_exception&gt;&gt;();
    } catch (...) {
      exception_thrown = true;
    }
    assert(exception_thrown);
#endif

    auto i4 = injector.create&lt;std::shared_ptr&lt;interface2&gt;&gt;();
    assert(i3);
    assert(i3 == i4);
    assert(1 == implementation::ctor_calls());
    assert(!implementation::dtor_calls());
  }
  //&lt;&lt;Destroyed with injector&gt;&gt;
  assert(1 == implementation::dtor_calls());
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/shared_factory.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/shared_factory.cpp</a></li>
</ul>
<h3 id="lazy">Lazy</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/injections/lazy.hpp&quot;

#include &lt;cassert&gt;
#include &lt;memory&gt;

namespace di = boost::di;

struct interface {
  virtual ~interface() noexcept = default;
  virtual void dummy1() = 0;
};

struct type_expensive_to_create : interface {
  void dummy1() override {}
};

/*&lt;&lt;example `example` class&gt;&gt;*/
class example {
 public:
  explicit example(di::extension::lazy&lt;std::unique_ptr&lt;interface&gt;&gt; l) : l(l) {}

  void initialize() {
    auto object = l.get();
    assert(dynamic_cast&lt;type_expensive_to_create *&gt;(object.get()));
  }

 private:
  di::extension::lazy&lt;std::unique_ptr&lt;interface&gt;&gt; l;
};

int main() {
  /*&lt;&lt;define injector&gt;&gt;*/
  auto injector = di::make_injector(
    di::bind&lt;interface&gt;().to&lt;type_expensive_to_create&gt;()
  );

  /*&lt;&lt;create `example`&gt;&gt;*/
  auto object = injector.create&lt;example&gt;();
  object.initialize();
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/lazy.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/lazy.cpp</a></li>
</ul>
<h3 id="named-parameters">Named Parameters</h3>
<pre><code class="cpp">
#include &quot;boost/di/extension/injections/named_parameters.hpp&quot;

#include &lt;cassert&gt;
#include &lt;memory&gt;

namespace di = boost::di;

struct interface {
  virtual ~interface() = default;
  virtual void dummy() = 0;
};

struct implementation : interface {
  void dummy() override {}
};

struct example {
  /*&lt;&lt;inject constructor using automatic named parameters&gt;&gt;*/
  $inject(example, int i, std::unique_ptr&lt;interface&gt; up, [[named(&quot;my_value&quot;)]] int value) {
    assert(i == 42);
    assert(dynamic_cast&lt;implementation*&gt;(up.get()));
    assert(value == 87);
  }
};

int main() {
  using namespace di::extension;

  /*&lt;&lt;bind named parameters&gt;&gt;*/
  auto injector = di::make_injector(
      di::bind&lt;int&gt;.to(42)
    , di::bind&lt;interface&gt;.to&lt;implementation&gt;()
    , di::bind&lt;int&gt;.named(&quot;my_value&quot;_s).to(87)
  );

  injector.create&lt;example&gt;();
}

</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/named_parameters.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/named_parameters.cpp</a></li>
</ul>
<h3 id="xml-injection">XML Injection</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/injections/xml_injection.hpp&quot;

#include &lt;cassert&gt;
#include &lt;iostream&gt;

namespace di = boost::di;


auto module = [] {
  return di::make_injector(
    di::bind&lt;di::extension::ixml_parser&gt;().to&lt;xml_parser_stub&gt;()
  );
};

auto xml_module = [] {
  return di::make_injector(
    di::bind&lt;interface&gt;().to(di::extension::xml&lt;implementation1, implementation2&gt;())
  );
};

int main() {
  /*&lt;&lt;make injector&gt;&gt;*/
  auto injector = di::make_injector(module(), xml_module());

  /*&lt;&lt;create `interface` from xml configuration&gt;&gt;*/
  {
    auto object = injector.create&lt;std::shared_ptr&lt;interface&gt;&gt;();
    assert(object.get());
    assert(dynamic_cast&lt;implementation1*&gt;(object.get()));
  }

  /*&lt;&lt;create `interface` from different xml configuration&gt;&gt;*/
  {
    auto object = injector.create&lt;std::shared_ptr&lt;interface&gt;&gt;();
    assert(object.get());
    assert(dynamic_cast&lt;implementation2*&gt;(object.get()));
  }

  /*&lt;&lt;create `interface` from different xml configuration&gt;&gt;*/
  {
    auto object = injector.create&lt;std::shared_ptr&lt;interface&gt;&gt;();
    assert(!object.get());
  }
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/xml_injection.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/injections/xml_injection.cpp</a></li>
</ul>
<h3 id="serialize">Serialize</h3>
<pre><code class="cpp">#define BOOST_DI_DISABLE_SHARED_PTR_DEDUCTION
#include &quot;boost/di/extension/policies/serialize.hpp&quot;

#include &lt;cassert&gt;
#include &lt;iostream&gt;

namespace di = boost::di;

struct data {
  unsigned int ui;
  long l;
  float f;
};

struct even_more_data {
  double d;
  bool b;
  long long ll;
};

struct more_data {
  int i;
  long double ld;
  even_more_data d;
  short s;
};

struct example {
  example(data&amp; d, more_data&amp; md) : d(d), md(md) {}

  void update() {
    d.ui = 13;
    d.l = 23l;
    d.f = .33f;
    md.i = 44;
    md.ld = 42.0;
    md.d.d = 55.0;
    md.d.b = true;
    md.d.ll = 66ll;
    md.s = 77;
  }

  void reset() {
    d.ui = {};
    d.l = {};
    d.f = {};
    md.i = {};
    md.ld = {};
    md.d.d = {};
    md.d.b = {};
    md.d.ll = {};
    md.s = {};
  }

  data&amp; d;
  more_data&amp; md;
};

int main() {
  auto injector = di::make_injector&lt;di::extension::serializable_policy&gt;(
      di::bind&lt;&gt;().to(42)
  );

  /*&lt;&lt;create `example`&gt;&gt;*/
  auto object = injector.create&lt;example&gt;();
  {
    assert(0 == object.d.ui);
    assert(0 == object.d.l);
    assert(.0f == object.d.f);
    assert(42 == object.md.i);  // bound
    assert(0.0 == object.md.ld);
    assert(0.0 == object.md.d.d);
    assert(false == object.md.d.b);
    assert(0 == object.md.d.ll);
    assert(0 == object.md.s);
  }

  /*&lt;&lt;update internal data&gt;&gt;*/
  object.update();
  {
    assert(13 == object.d.ui);
    assert(23 == object.d.l);
    assert(.33f == object.d.f);
    assert(44 == object.md.i);
    assert(42.0 == object.md.ld);
    assert(55.0 == object.md.d.d);
    assert(true == object.md.d.b);
    assert(66 == object.md.d.ll);
    assert(77 == object.md.s);
  }

  /*&lt;&lt;serialize internal data to the stream&gt;&gt;*/
  std::stringstream str;
  di::extension::serialize(injector, str);

  /*&lt;&lt;reset internal data&gt;&gt;*/
  object.reset();

  /*&lt;&lt;deserialize from the stream&gt;&gt;*/
  di::extension::deserialize(injector, str);
  {
    assert(13 == object.d.ui);
    assert(23 == object.d.l);
    assert(.33f == object.d.f);
    assert(44 == object.md.i);
    assert(42.0 == object.md.ld);
    assert(55.0 == object.md.d.d);
    assert(true == object.md.d.b);
    assert(66 == object.md.d.ll);
    assert(77 == object.md.s);
  }
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/serialize.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/serialize.cpp</a></li>
</ul>
<h3 id="types-dumper">Types Dumper</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/policies/types_dumper.hpp&quot;

#include &lt;memory&gt;

namespace di = boost::di;

auto int_1 = [] { return &quot;first int&quot;; };
auto int_2 = [] { return &quot;second int&quot;; };

struct i0 {
  virtual ~i0(){};
};
struct c0 : i0 {};
struct c1 {
  c1(std::shared_ptr&lt;i0&gt;, int) {}
};
struct c2 {
  BOOST_DI_INJECT(c2, (named = int_1) int, (named = int_2) int, char) {}
};
struct c3 {
  c3(std::shared_ptr&lt;c1&gt;, std::shared_ptr&lt;c2&gt;) {}
};

int main() {
  /*&lt;&lt;define injector&gt;&gt;*/
  auto injector = di::make_injector&lt;di::extension::types_dumper&gt;(
    di::bind&lt;i0&gt;().to&lt;c0&gt;()
  , di::bind&lt;int&gt;().named(int_1).to(42)
  , di::bind&lt;int&gt;().named(int_2).to(42)
  );

  /*&lt;&lt;iterate through created objects with `types_dumper`&gt;&gt;*/
  injector.create&lt;c3&gt;();

  /*&lt;&lt; output [pre
      (2c3 -&gt; 2c3)
          (St10shared_ptrI2c1E -&gt; 2c1)
              (St10shared_ptrI2i0E -&gt; 2c0)
              (i -&gt; i)
          (St10shared_ptrI2c2E -&gt; 2c2)
              (i[first int] -&gt; i)
              (i[second int] -&gt; i)
              (c -&gt; c)
  ]&gt;&gt;*/
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/types_dumper.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/types_dumper.cpp</a></li>
</ul>
<h3 id="uml-dumper">UML Dumper</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/policies/uml_dumper.hpp&quot;

#include &lt;memory&gt;

namespace di = boost::di;


int main() {
  /*&lt;&lt;define injector&gt;&gt;*/
  auto injector = di::make_injector&lt;di::extension::uml_dumper&gt;(
    di::bind&lt;i0&gt;().to&lt;c0&gt;()
  , di::bind&lt;int&gt;().named(int_1).to(42)
  , di::bind&lt;int&gt;().named(int_2).to(42)
  );

  /*&lt;&lt;iterate through created objects with `types_dumper`&gt;&gt;*/
  injector.create&lt;c3&gt;();

  /*&lt;&lt;output [@images/uml_dumper.png [$images/uml_dumper.png [width 75%] [height 75%] ]]&gt;&gt;*/
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/policies/uml_dumper.cpp</a></li>
</ul>
<p><a href="../images/uml_dumper.png"><img alt="UML Dumper" src="../images/uml_dumper.png" /></a></p>
<h3 id="heap-provider">Heap Provider</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/providers/heap.hpp&quot;

#include &lt;cassert&gt;
#include &lt;memory&gt;

namespace di = boost::di;

class new_call;
class del_call;

struct example {
  template &lt;class&gt;
  static auto &amp;calls() {
    static auto i = 0;
    return i;
  }

  void *operator new(size_t size) {
    ++calls&lt;new_call&gt;();
    return ::operator new(size);
  }

  void operator delete(void *ptr) {
    ++calls&lt;del_call&gt;();
    ::operator delete(ptr);
  }
};

int main() {
  struct heap_config : di::config {
    auto provider(...) const noexcept { return di::extension::heap{}; }
  };

  auto injector = di::make_injector&lt;heap_config&gt;();

  assert(0 == example::calls&lt;new_call&gt;());
  assert(0 == example::calls&lt;del_call&gt;());
  injector.create&lt;example&gt;();
  assert(1 == example::calls&lt;new_call&gt;());
  assert(1 == example::calls&lt;del_call&gt;());
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/heap.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/heap.cpp</a></li>
</ul>
<h3 id="mocks-provider">Mocks Provider</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/providers/mocks_provider.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;

struct i1 {
  virtual ~i1() noexcept = default;
  virtual int get() = 0;
};

struct i2 {
  virtual ~i2() noexcept = default;
  virtual int get() = 0;
};

struct c {
  c(std::shared_ptr&lt;i1&gt; sp, std::unique_ptr&lt;i2&gt; up, int i) {
    assert(sp-&gt;get() == 42);
    assert(up-&gt;get() == 123);
    assert(i == 87);
  }
};

int main() {
  /*&lt;&lt;unit test&gt;&gt;*/
  {
    /*&lt;&lt;create injector with `mocks_provider`&gt;&gt;*/
    auto mi = di::extension::mocks_injector();

    /*&lt;&lt;set expectations&gt;&gt;*/
    expect(mi, &amp;i1::get).will_return(42);
    expect(mi, &amp;i2::get).will_return(123);

    /*&lt;&lt;create object to test with interfaces to be injected by di and int value passed directly to constructor&gt;&gt;*/
    c object{mi, mi, 87};
  }

  /*&lt;&lt;integration test&gt;&gt;*/
  {
    struct impl1 : i1 {
      int get() override { return 42; }
    };

    /*&lt;&lt;create injector with `mocks_provider`&gt;&gt;*/
      auto mi = di::extension::mocks_injector(
        di::bind&lt;int&gt;().to(87) // custom value
      , di::bind&lt;i1&gt;().to&lt;impl1&gt;() // original implementation
      );

    /*&lt;&lt;set expectations&gt;&gt;*/
    expect(mi, &amp;i2::get).will_return(123);  // fake

    /*&lt;&lt;create object to test with mocked `i1` and original `i2` and injected int value&gt;&gt;*/
    mi.create&lt;c&gt;();
  }
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/mocks_provider.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/mocks_provider.cpp</a></li>
</ul>
<h3 id="runtime-provider">Runtime Provider</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/providers/runtime_provider.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;

struct i1 {
  virtual ~i1() noexcept = default;
  virtual int foo() const = 0;
};

struct i2 {
  virtual ~i2() noexcept = default;
  virtual int bar() const = 0;
};

struct impl2 : i2 {
  int bar() const override { return 99; }
};

struct impl1 : i1 {
  impl1(std::unique_ptr&lt;i2&gt; sp2) { assert(sp2-&gt;bar() == 99); }

  int foo() const override { return 42; }
};

struct example {
  example(std::shared_ptr&lt;i1&gt; sp, int i) {
    assert(dynamic_cast&lt;impl1*&gt;(sp.get()));
    assert(sp-&gt;foo() == 42);
    assert(i == 87);
  }
};

int main() {
  namespace di = boost::di;

  /*&lt;&lt;create runtime injector&gt;&gt;*/
  di::extension::injector injector{};

  /*&lt;&lt;install bindings&gt;&gt;*/
  injector.install(
    di::bind&lt;i1&gt;().to&lt;impl1&gt;(),
    di::bind&lt;i2&gt;().to&lt;impl2&gt;()
  );

  /*&lt;&lt;more bindings&gt;&gt;*/
  injector.install(di::bind&lt;int&gt;().to(87));

  /*&lt;&lt;create example&gt;&gt;*/
  injector.create&lt;example&gt;();

}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/runtime_provider.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/providers/runtime_provider.cpp</a></li>
</ul>
<h3 id="scoped-scope">Scoped Scope</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/scopes/scoped.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;


auto module = [] {
  return di::make_injector(
    di::bind&lt;interface1&gt;().to&lt;implementation1&gt;()
  );
};

int main() {
  assert(!implementation1::ctor_calls());
  assert(!implementation1::dtor_calls());
  assert(!implementation2::ctor_calls());
  assert(!implementation2::dtor_calls());

  auto parent_injector = module();
  /*&lt;&lt;create `interface1` using deduced singleton scope&gt;&gt;*/
  parent_injector.create&lt;interface1 &amp;&gt;();
  assert(1 == implementation1::ctor_calls());
  {
    /*&lt;&lt;create `child_injector` with `module` and binding using scoped singleton scope&gt;&gt;*/
    auto child_injector = di::make_injector(
        module()
      , di::bind&lt;interface2&gt;().to&lt;implementation2&gt;().in(di::extension::scoped)
    );
    child_injector.create&lt;interface2 &amp;&gt;();
    assert(1 == implementation2::ctor_calls());
  }  // end of scoped
  assert(1 == implementation2::dtor_calls());

  /*&lt;&lt;create `interface1` again in singleton scope&gt;&gt;*/
  parent_injector.create&lt;interface1 &amp;&gt;();
  /*&lt;&lt;already created&gt;&gt;*/
  assert(1 == implementation1::ctor_calls());
  /*&lt;&lt;`implementation1` will die with the app (static storage)&gt;&gt;*/
  assert(0 == implementation1::dtor_calls());
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/scoped.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/scoped.cpp</a></li>
</ul>
<h3 id="session-scope">Session Scope</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/scopes/session.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;


auto my_session = [] {};

int main() {
  {
    auto injector = di::make_injector(
      di::bind&lt;interface1&gt;().to&lt;implementation1&gt;().in(di::extension::session(my_session))
    );
    assert(!injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;());

    {
      auto ms = di::extension::session(my_session)();
      assert(injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;());
    }  // end of my_session

    assert(!injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;());
  }

  {
    di::injector&lt;std::shared_ptr&lt;interface1&gt;&gt; injector =
      di::make_injector(
        di::bind&lt;interface1&gt;().to&lt;implementation1&gt;().in(di::extension::session(my_session))
      );
    assert(!injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;());

    {
      auto ms = di::extension::session(my_session)();
      assert(injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;());
    }  // end of my_session

    assert(!injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;());
  }
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/session.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/session.cpp</a></li>
</ul>
<h3 id="shared-scope">Shared Scope</h3>
<pre><code class="cpp">#include &quot;boost/di/extension/scopes/shared.hpp&quot;

#include &lt;cassert&gt;

namespace di = boost::di;


auto name = [] {};

class example {
 public:
  BOOST_DI_INJECT(example, (named = name) std::shared_ptr&lt;interface1&gt; sp1, (named = name) std::shared_ptr&lt;interface1&gt; sp2,
                  std::shared_ptr&lt;interface1&gt; sp3) {
    assert(sp1 == sp2);
    assert(dynamic_cast&lt;implementation2*&gt;(sp1.get()));
    assert(dynamic_cast&lt;implementation2*&gt;(sp2.get()));
    assert(dynamic_cast&lt;implementation1*&gt;(sp3.get()));
  }
};

int main() {
  {
    auto injector = di::make_injector&lt;di::extension::shared_config&gt;(
      di::bind&lt;interface1&gt;().to&lt;implementation1&gt;().in(di::extension::shared)  // di::unique will fail (sp1 == sp2)
    , di::bind&lt;interface1&gt;().to&lt;implementation2&gt;().named(name).in(di::extension::shared)
    );
    injector.create&lt;example&gt;();
  }

  {
    di::injector&lt;std::shared_ptr&lt;interface1&gt;&gt; injector =
      di::make_injector&lt;di::extension::shared_config&gt;(
        di::bind&lt;interface1&gt;().to&lt;implementation1&gt;().in(di::extension::shared)
    );

    injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;();
    // injector.create&lt;std::unique_ptr&lt;interface1&gt;&gt;(); // error, std::unique_ptr&lt;interface1&gt; is not exposed
  }

  {
    di::injector&lt;BOOST_DI_EXPOSE((named = name)std::shared_ptr&lt;interface1&gt;), std::shared_ptr&lt;interface1&gt;&gt; injector =
        di::make_injector&lt;di::extension::shared_config&gt;(
        di::bind&lt;interface1&gt;().to&lt;implementation1&gt;().in(di::extension::shared).named(name)
      , di::bind&lt;interface1&gt;().to&lt;implementation2&gt;().in(di::extension::shared).named(name)[di::override]
      , di::bind&lt;interface1&gt;().to&lt;implementation1&gt;().in(di::extension::shared)
    );

    injector.create&lt;example&gt;();
  }

  {
    auto injector1 = di::make_injector&lt;di::extension::shared_config&gt;(di::bind&lt;interface1&gt;().to&lt;implementation1&gt;().in(di::extension::shared));

    auto i1 = injector1.create&lt;std::shared_ptr&lt;interface1&gt;&gt;();
    auto injector2 = di::make_injector&lt;di::extension::shared_config&gt;(std::move(injector1));
    // check whether shared scope was successfully moved
    assert(i1 == injector2.create&lt;std::shared_ptr&lt;interface1&gt;&gt;());
  }

  calls&lt;implementation1, ctor&gt;() = 0;
  calls&lt;implementation1, dtor&gt;() = 0;
  calls&lt;implementation2, ctor&gt;() = 0;
  calls&lt;implementation2, dtor&gt;() = 0;
  calls&lt;implementation3, ctor&gt;() = 0;
  calls&lt;implementation3, dtor&gt;() = 0;
  {
    const auto injector = di::make_injector&lt;di::extension::shared_config&gt;(
       di::bind&lt;implementation1&gt;().in(di::singleton)          /// explicit singleton scope
     , di::bind&lt;implementation2&gt;().in(di::extension::shared)  /// explicit shared scope
     , di::bind&lt;interface1&gt;().to&lt;implementation3&gt;()           /// deduced shared scope
    );

    injector.create&lt;implementation1&gt;();
    injector.create&lt;implementation2&gt;();
    assert(dynamic_cast&lt;interface1*&gt;(injector.create&lt;std::shared_ptr&lt;interface1&gt;&gt;().get()));

    assert((calls&lt;implementation1, ctor&gt;() == 2));
    assert((calls&lt;implementation1, dtor&gt;() == 1));

    assert((calls&lt;implementation2, ctor&gt;() == 2));
    assert((calls&lt;implementation2, dtor&gt;() == 1));

    assert((calls&lt;implementation3, ctor&gt;() == 1));
    assert((calls&lt;implementation3, dtor&gt;() == 0));

  }  // injector dies
  assert((calls&lt;implementation1, ctor&gt;() == 2));
  assert((calls&lt;implementation1, dtor&gt;() == 1));  // not destroyed

  assert((calls&lt;implementation2, ctor&gt;() == 2));
  assert((calls&lt;implementation2, dtor&gt;() == 2));  // explicit scope destroyed with injector

  assert((calls&lt;implementation3, ctor&gt;() == 1));
  assert((calls&lt;implementation3, dtor&gt;() == 1));  // deduced scope destroyed with config/injector
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/shared.cpp">https://raw.githubusercontent.com/boost-experimental/di/cpp14/extension/test/scopes/shared.cpp</a></li>
</ul>
</div>

<script src="../js/highlight.pack.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>

<div class="copyright-footer">Copyright &copy; 2012-2018 Kris Jusiak (kris at jusiak net)
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>

</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../examples/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../FAQ/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
    <option value="https://boost-experimental.github.io/di">Theme: Boost Experimental</option>
    <option value="https://boost-experimental.github.io/di/boost" selected>Theme: Boost Classic</option>
</select>
</body>
</html>